# googleSTEP Week4

## コードの説明
### 課題１
BFSをそのまま実装した。経路を保持する必要があるので、largeの探索でも空間計算量が耐えられるように、直接pathをリンクで保持するのではなく、親のidを子供が保持し、それを遡っていく形にした。

### 課題2
Random Surferモデルを実装した。リンク先を持たないノードについては、毎回そのノードについて全ノードにpagerankを分配するコードでは計算量が`O(N*E)`になってしまい計算が終わらなくなってしまうので、毎回そのノードについて計算をするのではなく、最初に孤立点の数をカウントし、それぞれのノードの初期化時に孤立点のpagerankを考慮し足し合わせる形にした。

### 課題3
あまりうまくいかなかった…
- find_most_popular_pages
最初は単純なDFSを考え、シンプルなDFSだとノードが多すぎて探索が終わらないため深さに制限をかけ、current_distanceをどれだけ伸ばせるか試したところ、とりあえず`9999`までは到達可能だった。
（途中の経路が不明、、）

- find_most_popular_pages2
先ほどの関数では、自分でcurrent_distanceを決定する必要があり、それ以上の長さの経路は見つけることができない。そこで、次にBFSベースでコードを考え、課題2で使ったpagerankをうまく活かせないか…？とdistanceとpagerankの和によって探索の優先度を変更する関数を考えた。
しかしこれでは探索の深さに制限をかけなければ長さ1の経路も見つけることができず、断念。
優先度scoreの算出方法などにもう少し改善点がありそう。

一番現実的に長さを伸ばすなら、find_most_popular_pagesである程度の長い経路を見つけ、その経路にうまーくfind_most_popular_pages2を適用し（ランダムとかで）リンク先が多そうなノードに飛び、長さを増やしていくのがいいんだろうか、、

